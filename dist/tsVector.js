"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});function C(t,r){return t+r}function E(t,r){return t-r}function c(t){return Array(t).fill(0)}function p(t,r){let n=c(t.length);for(let e=0;e<t.length;e++)n[e]=t[e]+r[e];return n}function S(t,r){let n=c(t.length);for(let e=0;e<t.length;e++)n[e]=Math.min(t[e],r[e]);return n}function Z(t,r){let n=c(t.length);for(let e=0;e<t.length;e++)n[e]=Math.max(t[e],r[e]);return n}function M(t,r){let n=c(r.length);for(let e=0;e<r.length;e++)n[e]=t*r[e];return n}function v(t,r){return p(t,M(-1,r))}function d(t){return Math.sqrt(t.reduce((r,n)=>r+n*n,0))}function x(t){return M(1/d(t),t)}function y(t,r=1e-6){return d(t)<r}function L(t,r,n=1e-6){return y(v(t,r),n)}function P(t,r){const[n,e,l]=t,[o,s,i]=r;return[e*i-l*s,l*o-n*i,n*s-e*o]}function a(t,r){return Array(t).fill(0).map(()=>c(r))}function R(t,r=[0,0,0]){t===null&&(t=g(3));let n=a(4,4);for(let e=0;e<3;e++){for(let l=0;l<3;l++)n[e][l]=t[e][l];n[e][3]=r[e]}return n[3][3]=1,n}function f(t,r=!1){let n=t.length,e=t[0].length;if(r){for(let l=1;l<n;l++)if(t[l].length!==e)throw new Error(`Row ${l} has ${t[l].length} columns, expected ${e}`)}return[t.length,t[0].length]}function g(t){let r=a(t,t);for(let n=0;n<t;n++)r[n][n]=1;return r}function A(t,r){let n=c(t.length);for(let e=0;e<t.length;e++)for(let l=0;l<t[e].length;l++)n[e]+=t[e][l]*r[l];return n}function N(t,r){const[n,e]=f(t),[l,o]=f(r);if(e!==l)throw new Error(`Matrix A has ${e} columns, Matrix B has ${l} rows. Cannot multiply.`);let s=a(n,o);for(let i=0;i<n;i++)for(let u=0;u<o;u++)for(let h=0;h<e;h++)s[i][u]+=t[i][h]*r[h][u];return s}function w(t){return t.map(r=>r.slice())}function T(t,r=.001){return t.map(n=>n.map(e=>Math.abs(e-Math.round(e))<r?Math.round(e):e))}function q(t,r){return A(t,r.concat(1)).slice(0,3)}function z(t){return t.reduce((r,n)=>r.concat(n),[])}function B(t,r,n){if(t.length!==r*n)throw new Error(`List length ${t.length} does not match ${r}x${n} matrix`);let e=a(r,n);for(let l=0;l<r;l++)for(let o=0;o<n;o++)e[l][o]=t[l*n+o];return e}function m(t,r,n,e=!1){let l=t;e||(l=w(t));let o=l[r];return l[r]=l[n],l[n]=o,l}function j(t,r){const[n,e]=f(t),[l,o]=f(r);if(n!==l)throw new Error(`Matrix M1 has ${n} rows, Matrix M2 has ${l} rows. Cannot adjoin.`);let s=a(n,e+o);for(let i=0;i<n;i++){for(let u=0;u<e;u++)s[i][u]=t[i][u];for(let u=0;u<o;u++)s[i][e+u]=r[i][u]}return s}function $(t,r,n,e,l){let o=a(n-r,l-e);for(let s=r;s<n;s++)for(let i=e;i<l;i++)o[s-r][i-e]=t[s][i];return o}function b(t){let r=w(t),[n,e]=f(r),l=0;for(let o=0;o<n;o++){if(e<=l)return r;let s=o;for(;r[s][l]===0;)if(s++,n===s&&(s=o,l++,e===l))return r;r=m(r,s,o);let i=r[o][l];r[o]=r[o].map(u=>u/i);for(let u=0;u<n;u++)u!==o&&(i=r[u][l],r[u]=v(r[u],M(i,r[o])));l++}return r}function I(t){let[r,n]=f(t);if(r!==n)throw new Error("Matrix is not square, cannot invert.");let e=j(t,g(r));return e=b(e),$(e,0,r,r,2*r)}function k(t){var r=Math.cos(t),n=Math.sin(t),e=[[r,-n,0],[n,r,0],[0,0,1]];return e}function O(t){var r=Math.cos(t),n=Math.sin(t),e=[[1,0,0],[0,r,n],[0,-n,r]];return e}function D(t){var r=Math.cos(t),n=Math.sin(t),e=[[r,0,n],[0,1,0],[-n,0,r]];return e}exports.MAdjoin=j;exports.MAsList=z;exports.MCopy=w;exports.MInverse=I;exports.MMProduct=N;exports.MRowEchelon=b;exports.MTolerate=T;exports.Mpitch=D;exports.Mroll=k;exports.Mshape=f;exports.Mslice=$;exports.MswapRows=m;exports.MvProduct=A;exports.Myaw=O;exports.add=C;exports.affine3d=R;exports.applyAffine3d=q;exports.eye=g;exports.listAsM=B;exports.mZero=a;exports.subtract=E;exports.vAdd=p;exports.vClose=L;exports.vCross=P;exports.vLength=d;exports.vMax=Z;exports.vMin=S;exports.vNearlyZero=y;exports.vNormalize=x;exports.vScale=M;exports.vSub=v;exports.vZero=c;

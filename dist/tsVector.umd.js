(function(u,M){typeof exports=="object"&&typeof module<"u"?M(exports):typeof define=="function"&&define.amd?define(["exports"],M):(u=typeof globalThis<"u"?globalThis:u||self,M(u.tsVector={}))})(this,function(u){"use strict";function M(t,e){return t+e}function Z(t,e){return t-e}function a(t){return Array(t).fill(0)}function A(t,e){let r=a(t.length);for(let n=0;n<t.length;n++)r[n]=t[n]+e[n];return r}function L(t,e){let r=a(t.length);for(let n=0;n<t.length;n++)r[n]=Math.min(t[n],e[n]);return r}function P(t,e){let r=a(t.length);for(let n=0;n<t.length;n++)r[n]=Math.max(t[n],e[n]);return r}function v(t,e){let r=a(e.length);for(let n=0;n<e.length;n++)r[n]=t*e[n];return r}function g(t,e){return A(t,v(-1,e))}function R(t,e){return t.reduce((r,n,l)=>r+n*e[l],0)}function w(t){return Math.sqrt(t.reduce((e,r)=>e+r*r,0))}function T(t){return v(1/w(t),t)}function j(t,e=1e-6){return w(t)<e}function N(t,e,r=1e-6){return j(g(t,e),r)}function q(t,e){const[r,n,l]=t,[i,c,f]=e;return[n*f-l*c,l*i-r*f,r*c-n*i]}function s(t,e){return Array(t).fill(0).map(()=>a(e))}function z(t,e=[0,0,0]){t===null&&(t=y(3));let r=s(4,4);for(let n=0;n<3;n++){for(let l=0;l<3;l++)r[n][l]=t[n][l];r[n][3]=e[n]}return r[3][3]=1,r}function h(t,e=!1){let r=t.length,n=t[0].length;if(e){for(let l=1;l<r;l++)if(t[l].length!==n)throw new Error(`Row ${l} has ${t[l].length} columns, expected ${n}`)}return[t.length,t[0].length]}function y(t){let e=s(t,t);for(let r=0;r<t;r++)e[r][r]=1;return e}function $(t,e){let r=a(t.length);for(let n=0;n<t.length;n++)for(let l=0;l<t[n].length;l++)r[n]+=t[n][l]*e[l];return r}function B(t,e){const[r,n]=h(t),[l,i]=h(e);if(n!==l)throw new Error(`Matrix A has ${n} columns, Matrix B has ${l} rows. Cannot multiply.`);let c=s(r,i);for(let f=0;f<r;f++)for(let o=0;o<i;o++)for(let d=0;d<n;d++)c[f][o]+=t[f][d]*e[d][o];return c}function m(t){return t.map(e=>e.slice())}function D(t,e=.001){return t.map(r=>r.map(n=>Math.abs(n-Math.round(n))<e?Math.round(n):n))}function I(t,e){return $(t,e.concat(1)).slice(0,3)}function k(t){return t.reduce((e,r)=>e.concat(r),[])}function O(t,e,r){if(t.length!==e*r)throw new Error(`List length ${t.length} does not match ${e}x${r} matrix`);let n=s(e,r);for(let l=0;l<e;l++)for(let i=0;i<r;i++)n[l][i]=t[l*r+i];return n}function b(t,e,r,n=!1){let l=t;n||(l=m(t));let i=l[e];return l[e]=l[r],l[r]=i,l}function C(t,e){const[r,n]=h(t),[l,i]=h(e);if(r!==l)throw new Error(`Matrix M1 has ${r} rows, Matrix M2 has ${l} rows. Cannot adjoin.`);let c=s(r,n+i);for(let f=0;f<r;f++){for(let o=0;o<n;o++)c[f][o]=t[f][o];for(let o=0;o<i;o++)c[f][n+o]=e[f][o]}return c}function E(t,e,r,n,l){let i=s(r-e,l-n);for(let c=e;c<r;c++)for(let f=n;f<l;f++)i[c-e][f-n]=t[c][f];return i}function S(t){let e=m(t),[r,n]=h(e),l=0;for(let i=0;i<r;i++){if(n<=l)return e;let c=i;for(;e[c][l]===0;)if(c++,r===c&&(c=i,l++,n===l))return e;e=b(e,c,i);let f=e[i][l];e[i]=e[i].map(o=>o/f);for(let o=0;o<r;o++)o!==i&&(f=e[o][l],e[o]=g(e[o],v(f,e[i])));l++}return e}function V(t){let[e,r]=h(t);if(e!==r)throw new Error("Matrix is not square, cannot invert.");let n=C(t,y(e));return n=S(n),E(n,0,e,e,2*e)}function F(t){var e=Math.cos(t),r=Math.sin(t),n=[[e,-r,0],[r,e,0],[0,0,1]];return n}function G(t){var e=Math.cos(t),r=Math.sin(t),n=[[1,0,0],[0,e,r],[0,-r,e]];return n}function H(t){var e=Math.cos(t),r=Math.sin(t),n=[[e,0,r],[0,1,0],[-r,0,e]];return n}u.MAdjoin=C,u.MAsList=k,u.MCopy=m,u.MInverse=V,u.MMProduct=B,u.MRowEchelon=S,u.MTolerate=D,u.Mpitch=H,u.Mroll=F,u.Mshape=h,u.Mslice=E,u.MswapRows=b,u.MvProduct=$,u.Myaw=G,u.add=M,u.affine3d=z,u.applyAffine3d=I,u.eye=y,u.listAsM=O,u.mZero=s,u.subtract=Z,u.vAdd=A,u.vClose=N,u.vCross=q,u.vDot=R,u.vLength=w,u.vMax=P,u.vMin=L,u.vNearlyZero=j,u.vNormalize=T,u.vScale=v,u.vSub=g,u.vZero=a,Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});
